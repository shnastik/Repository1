/*************************************************************
	Практическое занятие №2. Побитовые операторы.
							Директивы препроцессора.
							Указатели.
*************************************************************/

#include <iostream>
#include <tchar.h>
#include <cmath>
#include <string>

//#define	  stop __asm nop	//с помощью директивы препроцессора задаем
							//макроподстановку

#define stop do{ } while(0)

/***************************************************************
Задания, отмеченные * , не являются обязательными!
***************************************************************/

int main()
{
// ********************************************************
	//Задание 1. Побитовая арифметика (and, or, xor, not), сдвиги.
	//1.1
	{
		int y;//Задайте значение y, например, с помощью потока ввода
		std::cout << "1.1 Enter y: ";
		std::cin >> y;

		//С помощью побитовых операторов и операторов сдвига выведите значение "y"
		//на консоль в двоичном виде, например:
		//если y==9, то
		// а) 0 0 0 0 ...   0 0 1 0 0 1 (количество двоичных цифр зависит от платформы)
		for(int i = sizeof(int)*8 - 1; i >= 0; i--)
			std::cout << " " << ((y >> i) & 1);
		std::cout << std::endl;


		//или пропустите незначащие нули - б) 1 0 0 1
		bool zeros = false;
		
		for(int i = sizeof(int)*8 - 1; i >= 0; i--)
		{
			int value = (y >> i) & 1;

			if(value)
				zeros = true;
			
			if(zeros)
				std::cout << " " << value;
		}
		std::cout << std::endl;
		
		stop;
	}
	
	//1.2 Дана целая переменная
	{
		int y;//Задайте значение y, например, с помощью потока ввода
		std::cout << "1.2 Enter y: ";
		std::cin >> y;

		//"Сдвиньте" все единицы в этой переменной вправо, например:
		//было:   0100 1111 0000 0000 0110 1111 0000 0010
		//стало:  0000 0000 0000 0000 0000 1111 1111 1111
		//Реализовать задачу посредством одного цикла!
		int res = 1;
		for(int i = sizeof(int)*8 - 1; i >= 0; i--)
		{
			if((y >> i) & 1)
				res <<= 1;
		}
		res--;
		
		for(int i = sizeof(int)*8 - 1; i >= 0; i--)
			std::cout << " " << ((res >> i) & 1);
		std::cout << std::endl;

		stop;
	}


	//1.3* Какие операции следует применить к заданному ниже операнду sNum для
	//того, чтобы переменная sRes приняла требуемое значение?
	//Замечание 1: значения подобраны таким образом, что в каждом случае достаточно
	//использовать один оператор (и при необходимости маску) 
	//Замечание 2: посредством оператора xor (подобрав соответствующую маску)
	//можно получить любое значение => этот оператор предполагается использовать
	//в том случае, когда все остальные уже "не спасают" 
	{
		short sNum = 0x8008;
		short sRes;

		sRes = ~sNum; //0x7ff7

		sRes = sNum | 0x0ff0; //0x8ff8

		sRes = sNum & 0x000f; //0x0008

		sRes = sNum ^ 0xff00; //0x7f08

		sRes = sNum ^ 0x7009; //0xf001

		sRes = sNum ^ 0x8018; //0x0010

		stop;
	}

	
// ********************************************************
	//Задание 2. Директивы препроцессора

	//2.1. Использование "математических" макросов стандартной библиотеки:
	//в заголовочном файле <cmath> (который в свою очередь включает старый
	//файл math.h) определены часто используемые математические
	//константы, например M_PI. Воспользуйтесь этой константой для
	//вычисления длины окружности.
	//Обратите внимание: определения констант в свою очередь тоже заключены
	//в директивы условной трансляции. Что еще, кроме подключения заголовочного
	//файла, требуется сделать???
	
	//Добавить в директивы препроцессора _USE_MATH_DEFINES

#include <cmath>
#include <math.h>
#ifndef M_PI
#define M_PI std::acos(-1)
#endif

	//2.2.Макросы с параметрами.
	//2.2.1 Напишите свою макроподстановку LENGHT которая вычисляет длину окружности.
	// протестируйте написанный макрос для следующих ситуаций:

#define LENGTH(x) (2 * M_PI * (x))
	
	{
		float l1 = LENGTH(1 + 2); // должно быть 18.8495...
		float l2 = 1 / LENGTH(2); // должно быть 0.07957...
		stop;
	}

	//2.2.2* определите макрос MAX(A, B)  для вычисления б'ольшего
	//значения из двух.
	
	//Используйте макрос следующим образом. Следите за изменением
	//значений переменных k, i, j. Объясните результат.
	//Постарайтесь убрать побочные эффекты.
	//Отметьте случаи, когда избежать побочных эффектов невозможно

#define MAX(A, B) ((A > B) ? (A) : (B))

	{
		int i = 10, j = 12, k;
		k = MAX(i, j);//(10 > 12) ? 10 : 12
		k = MAX(j, i) * 2;//(12 > 10) ? 12 : 10 * 2
		k = MAX(j, i+3);//12 > 10+3 ? 12 : 10 + 3
		k = MAX(i--, j++);//9-- > 12++ ? 9-- : 12++ //избежать побочных эффектов невозможно переменная j изменится 2 раза. k = 13 

		stop;
	}

	//2.2.3 определите макрос EXCHANGE(X, Y)  для перестановки
	//двух объектов типа int в памяти местами. Проверьте для приведенного
	//фрагмента. Подумайте, что будет делать макроподстановка, если
	//переставляемые значения разного типа???
	
#define EXCHANGE(X, Y) {int temp = X; X = Y; Y = temp;}

	{
		int x1=1, y1=-1;
		EXCHANGE(x1,y1);

		int x2=100, y2=-100;
		EXCHANGE(x2,y2);

		stop;
	}

	//2.3. Директивы условной трансляции
	//Выполняя следующий фрагмент, посмотрите, какое
	//значение принимает переменная iNN. Что нужно сделать
	//для того, чтобы результат был равен 0? 1? 2?
	
	//Без define'ов iNN = -1;
	//Для 0: #define NNN
	//		 #define MMM
	//Для 1: #define MMM
	//Для 2: #define NNN

int iNN;
#if defined NNN && defined MMM
	iNN = 0;
#elif defined MMM
	iNN = 1;
#elif defined NNN 
	iNN = 2;

#else
	iNN = -1;
#endif
	
	stop;
	

	//Задание 2.4. Загляните в Project/Properties -> диалоговая панель
	//- Property Pages/C\C++/Preprocessor/Preprocessor definitions.
	//В опциях командной строки в зависимости от мишени сборки проекта
	//(Debug или Release) может быть определено с помощью ключа /D
	//имя _DEBUG. С помощью директив условной
	//трансляции напишите фрагмент кода, который в зависимости от типа
	//мишени выводит с помощью cout разный текст на консоль. Проверьте
	//при разных мишенях сборки.

	//Пусть
	//для мишени Debug в процессе выполнения данного участка
	//кода на экран выводится информация об
	//имени файла, номере строки с функцией вывода, дате и времени 
	//компиляции файла, содержащего данную функцию вывода,
	//а также имя функции, содержащей данную строку.
#ifdef _DEBUG
	std::cout << "Debug information: " << __FILE__ << std::endl << "line: " << __LINE__ 
	<< " date/time: " <<__DATE__ << " " << __TIME__ << " f: " << __FUNCTION__ << std::endl;
#else
	std::cout << "Release configuration!" << std::endl;
#endif
	//Для мишени Release должна быть просто выведена строка
	//"Release configuration!"

	//Подсказка: для получения нужной информации введите в инструментальном
	//окне 'Index' справочной системы следующую ключевую фразу:	Predefined Macros
	
	//Подсказка: мишень сборки проекта можно
	//поменять следующим образом - Build/Configuration Manager/Configuration




	//Задание 2.5.* Управляя определенностью идентификатора _UNICODE и используя
	//возможности заголовочного <tchar.h>, определите и проинициализируйте переменную,
	//которая может становиться как однобайтовой, так и расширенной без 
	//изменения исходного текста.
	//С помощью отладчика проверьте результат.
#ifdef _UNICODE
	typedef wchar_t TCHAR;
	TCHAR var = L'Ш';
#else
	typedef char TCHAR;
	TCHAR var = 'Ш';
#endif


// ********************************************************
	//Задание 3.Заголовочные файлы. Директива #include
	//3.1.Создайте и подключите к проекту два заголовочных файла 1.h и 2.h
	//В каждом заголовочном файле объявите перечисление с одинаковыми именами
	//констант, но сопоставьте именованным константам разные значения, например:
	//1.h - enum MyEnum{My1, My2, My3};  . 2.h - enum MyEnum{My1=5, My2, My3};
	//С помощью директив условной трансляции в DEBUG-версии пользуйтесь значениями
	//констант из 1.h, а в RELEASE-версии значениями констант из 2.h
#ifdef _DEBUG
#include "1.h"
#else
#include "2.h"
#endif


// ********************************************************

	//Задание 4. Указатели
	//Объявите объекты разных типов и проинициализируйте их.
	//Объявите указатели соответствующих типов и проинициализируйте их
	//адресами заданных объектов. 
	//Выполняя задание, с помощью отладчика посмотрите, какие значения
	//будут присвоены переменным-указателям и на что эти указатели
	//"указывают"
	{
		bool b = true;
		char c = 'q';
		short s = 12000;
		int i = 100000;
		float f = 17.0;
		double d = 18.12343434;

		bool *pB = &b; // *pB = true
		char *pC = &c; // *pC = 113 'q
		short *pS = &s; //*pS = 12000
		int *pI = &i; // *pI =100000
		float *pf = &f; // *pf = 17
		double *pD = &d; // *pD = 18.1234

        // Итог: в значения переменных-указателей будут переданы значения. соответствующие ссылкам

		stop;
	}


	//Задание 4а. Объявите указатель на тип char и проинициализируйте
	//его адресом строкового литерала. Присвойте переменной типа char значение
	//любого элемента строки.
	//Проверьте - возможно ли присвоить какое-либо значение по адресу,
	//задаваемому указателем?
	{
		const char *str = "Hello";
		char c = str[1];

		std::cout<< c <<std::endl;
		//str[2] = 'A'; //Нельзя изменить значение используя указатель, т.к. строковый литерал находится в памяти доступной только для чтения

		stop;
	}

	//Задание 5. Арифметика указателей. Операция разыменования указателя.
	//Выполняя задание, следите за изменением значений
	//указателей и значений объектов, на которые они указывают.
	//Интерпретируте наблюдаемые результаты
	{
		int nAr[3] = {1,3}; 
		int *pn = &nAr[0];
		(*pn)++;	//0-й элемент массива nAr увеличился на 1, т.к. указатель pn содержал адрес 0-го элемента
		pn++;	//указатель сдвинулся на следующий элемент (1-й, если считать с 0-го элемента)

		char cAr[]={'A','B','C','D'};
		char *pc = &cAr[0]; //pc содержит адрес 0-го элемента массива cAr
		(*pc)=(*pc)+5;	//взятие значения по адресу pc 'A' (65) и увеличение его на 5, 
						//в результате получается значение 'F' (70), которое будет записано 
						//по адресу pc вместо 0-го элемента
		pc=pc+3;	//указатель указывает на 3-й элемент массива cAr (счет с 0-го)
	
		double dAr[3]={1.0,2.0};
		double *pd1 = &dAr[0];
		double *pd2 = pd1;
		(*pd2)+=2; //pd2 - указывает на 0-й элемент. После разыменования и прибавления 2,
				   //значение 0-го элемента изменится на 3.0. 
		pd2+=2; //указатель pd2, теперь указывает на 2-й элемент (счет с 0-го)

		//Объясните результат выполнения операции
		//вычитания двух указателей
		pd1 = &dAr[0];
		pd2 = &dAr[1];
		int nNumber=pd2 - pd1; //операция вычитания указателей имеет смысл для определения 
							   //количества элементов между двумя указателями в рамках одного массива
							   //nNumber = 1

		//Сравните указатели pd2 и pd1 и с помощью cout
		//выведите результаты сравнения.
		std::cout << "5. Compare result is: " << (pd2 > pd1 ? "true" : "false") << std::endl;

		stop;
	}


	//Задание 6. Явное преобразование указателя. Иногда возникает
	//необходимость одни и те же данные интерпретировать по-разному,
	//например, целое можно представить как совокупность четырех
	//байтов и работать с каждым байтом по отдельности. Для этого
	//нужно иметь возможность "указывать" как на целое, так и на байт. 
	//Следовательно, возникает необходимость явного преобразования
	//указателя. 
	//Подсказка: для правильной интерпретации этого задания воспользуйтесь
	//возможностями отладчика представлять данные в интересующем
	//Вас виде (в данном случае - в шестнадцатеричном) - для
	//этого используйте правую клавишу мыши,находясь в окне
	//переменных и изменяйте пункт - Hexadecimal display

    unsigned int nObject5=0x55667788;
	unsigned int* pnObject5=&nObject5;

	//Раскомментировав следующую строчку кода, обратите внимание
	//на сообщение компилятора - он не считает преобразование 
	//"легальным" (безопасным)
	unsigned char* pucObject5;
//	pucObject5=static_cast<unsigned char*>(pnObject5);	//(1) 'static_cast' : cannot convert from 'unsigned int *' to 'unsigned char *'	
	pucObject5=reinterpret_cast<unsigned char*>(pnObject5);	//а такое
				//преобразование - целиком на совести программиста.
				//Его можно применять, только четко представляя себе
				//результат преобразования (2) pucObject5 указывает только на младший байт переменной nObject5

	//Откомментируйте следующие строчки сс==..., p - изменился? *p=...
	char cc = *(pucObject5++); //сс==0x88, после присваивания указатель pucObject5 изменился на следующий байт, *pucObject5=0x88
	cc = (*pucObject5)++; //сс==0x77, указатель pucObject5 не изменился, после присваивания значение по указателю *pucObject5=0x78

	cc = ++*(pucObject5); //сс==0x79, указатель pucObject5 не изменился, *pucObject5=0x79 
	cc = *(++pucObject5); //сс==0x66, указатель pucObject5 изменился на следующий байт, *pucObject5=0x66
	stop;


	//Задание 7. Void-указатель. 
	//Выполняя задание, посмотрите - какие значения присваиваются
	//void-указателю. Обратите внимание: средствами отладчика Вы
	//не можете посмотреть значения, на которые "указывает"
	//void-указатель
	void*	pVoid;	//объявление void-указателя
	int	nObject3=5;
	char cObject3='A';
	int*	pInt = &nObject3;	
	pVoid=&nObject3;
	pVoid=&cObject3;
	pVoid=pInt;
	
	//Прежде, чем раскомментировать следующую строчку, вспомните:
	//что нужно сделать, чтобы выражение стало корректным 	
	pInt=static_cast<int*>(pVoid);

	//Что нужно сделать для того, чтобы следующее закомментированное выражение
	//стало корректным?
	{
		const int n = 1;
		const void *cpVoid = &n;//????объявить слева void-указатель
	}



	//7a. При выполнении следующего фрагмента посмотрите, какие неприятности
	//могут Вас ожидать при явном приведении типа void-указателя,
	//который в момент времени (1) указывает на double, к типу 
	//указателя на int (2) 

	double dObject3 = 33.33;
	pVoid = &dObject3;	//(1)

	int nTmp = *(static_cast<int*>(pVoid) ); //(2) из-за разного представления чисел с плавающей точкой и целых
											 //в переменную nTmp попало значение 0x70a3d70a
	stop;

		//Задание 8*. Модификатор const. В каждом из заданий
		//объявите указатель требуемого вида. Посредством каждого
		//указателя попробуйте:
		//получить значение по адресу
		//записать новое значение по адресу
		//модифицировать указатель
	{
		//Задание 8a. Указатель является константой. 
		int int1 = 5;
		int * const pint1 = &int1;
		std::cout << "8a. " << *pint1 << std::endl;
		*pint1 = 100;
		//pint1++; запрещено модифицировать значение константного указателя
	}
	stop;


		//Задание 8б. Указываемое значение является константой.
	{
		int int1 = 7;
		const int * pint1 = &int1;
		std::cout << "8b. " << *pint1 << std::endl;
		//*pint1 = 100; запрещено модифицировать значение по адресу указателя
		pint1++;
	}
	stop;


		//Задание 8в. И указатель, и указываемое значение
		//являются константами. 
	{
		int int1 = 70;
		const int * const pint1 = &int1;
		std::cout << "8v. " << *pint1 << std::endl;
		//*pint1 = 100; запрещено модифицировать значение по адресу указателя
		//pint1++; запрещено модифицировать значение константного указателя
	}


	stop;

	{
		//Задание 8г. Указатель на переменную, объявленную с
		//ключевым словом const. 
		const int nN = 1;

		//Объявите указатель и проинициализируйте его выражением - &nN	
		const int *pint2 = &nN;
	}

	stop;



	//Задание 9.При выполнении задания обратите внимание на то,
	//как наглядно отладчик "раскрывает" конструкции типа
	//"указатель на указатель" и на способы получения конечного
	//объекта по таким "иерархическим" указателям

	{
		int	n1=1;

		//Объявите указатель pn и проинициализируйте его так, чтобы он
		//"указывал" на n1
		int *pn = &n1;


		//Объявите указатель ppn и проинициализируйте его так, чтобы он
		//"указывал" на pn
		int **ppn = &pn;


		//Объявите указатель pppn и проинициализируйте его так, чтобы он
		//"указывал" на ppn
		int ***pppn = &ppn;


		//С помощью указателей pn, ppn и ppn получите значение объекта n1
		//и присвойте его n2

		int n2;
		n2 = *pn;
		n2 = **ppn;
		n2 = ***pppn;
		stop;
	}
	
		
	return 0;
}